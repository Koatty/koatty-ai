下面给出一个“智能化 Koatty 脚手架系统”的可落地方案，目标是：用户只需用自然语言描述需求，工具就能**按 Koatty 的工程结构与编程范式**自动生成 controller/model/dto/service/迁移脚本等，并可选择自动初始化数据库表结构。

---

## 1. 总体目标与原则

### 目标
- **场景1：新建项目**  
  用户输入“新建项目”，工具调用 `koatty_cli new` + 模板/预设，一键初始化工程骨架。
- **场景2：新增功能**（例：用户管理）  
  用户输入“新增用户管理功能”，工具自动生成：
  - controller（REST API）
  - service（业务逻辑）
  - model/entity（数据模型）
  - dto（入参/出参/校验）
  - 路由/模块注册（若需要）
  - 数据库表结构（迁移/同步）
  - 可选：单元测试、OpenAPI/Swagger、权限中间件挂载等

### 原则（让系统“可控、可迭代、可维护”）
1. **先结构化需求，再生成代码**：自然语言 → 结构化 Spec（JSON/YAML）→ 代码生成/修改。
2. **生成是可重复的（idempotent）**：同一 Spec 反复执行不会造成重复代码；基于 AST/模板标记做增量更新。
3. **可回滚**：每次生成/修改都落地为 git commit 或 patch，支持 `undo`。
4. **RAG + Koatty范式对齐**：基于 Koatty 文档（https://koatty.org）做检索增强，确保生成的目录结构、装饰器/依赖注入、异常处理、响应风格一致。
5. **生成后自动验证**：format/lint/typecheck/test + 可选本地启动 smoke test。

---

## 2. 系统架构设计

### 2.1 组件划分

**A. CLI 主程序（ktty-ai / koatty-ai-cli）**
- 命令示例：
  - `ktty-ai new <project-name>`（封装 `koatty_cli new`）
  - `ktty-ai add "新增用户管理功能"`（自然语言生成）
  - `ktty-ai plan "..."`（仅输出方案与改动清单，不落地）
  - `ktty-ai apply`（执行落地）
  - `ktty-ai undo`（回滚最近一次变更）
- 负责：参数解析、交互式提问、调用生成管线、落盘、执行校验命令。

**B. 需求理解与规划（Planner）**
- 输入：用户自然语言 + 当前工程信息（package.json、目录树、已有模块）+ Koatty 文档检索结果
- 输出：结构化 Spec（建议落在 `./.koatty-ai/specs/*.yml`），例如：
  ```yaml
  feature: user-management
  module: user
  api:
    basePath: /users
    endpoints:
      - method: GET
        path: /
        action: list
      - method: POST
        path: /
        action: create
      - method: GET
        path: /:id
        action: detail
      - method: PUT
        path: /:id
        action: update
      - method: DELETE
        path: /:id
        action: remove
  model:
    name: User
    table: users
    fields:
      - name: id
        type: number
        primary: true
      - name: username
        type: string
        unique: true
      - name: passwordHash
        type: string
      - name: email
        type: string
        nullable: true
      - name: createdAt
        type: datetime
  dto:
    create: [username, password, email]
    update: [email, password]
  auth:
    required: true
    roles: [admin]
  db:
    strategy: migration   # or sync
  ```
- 规划阶段应**尽量问清关键问题**（交互式）：
  - 需要哪些字段？必填/唯一？密码如何存（hash）？
  - 接口是否需要鉴权？权限策略？
  - DB 类型/ORM/迁移方案？
  - 是否要分页、模糊搜索、排序？

**C. Koatty 文档与工程知识库（RAG）**
- 将 Koatty 文档、示例项目、团队最佳实践沉淀为检索库：
  - 文档抓取 → 分块 → embedding → 向量检索
- 生成/修改代码时，把“与本次生成相关的 Koatty 范式片段”注入上下文（例如 controller 装饰器、依赖注入写法、异常与返回规范等）。

**D. 代码生成器（Generators）—插件化**
按组件拆成多个 generator，可组合执行：
- `ProjectGenerator`：初始化项目后做二次增强（eslint/prettier、环境配置、docker、基础模块等）
- `ModuleGenerator`：创建模块目录结构
- `ModelGenerator`：生成 Model/Entity（按 Koatty 推荐写法）
- `DtoGenerator`：生成 DTO + 校验规则
- `ServiceGenerator`：生成 CRUD service、事务/错误处理
- `ControllerGenerator`：生成控制器/路由绑定
- `MigrationGenerator`：生成迁移文件或 schema 同步脚本
- `TestGenerator`：生成单测/接口测试（可选）
- `DocGenerator`：生成 OpenAPI（可选）

> 插件输出统一为 `ChangeSet`（文件新增/修改/删除 + patch），方便 dry-run、审阅与回滚。

**E. 代码修改器（AST Patcher）**
- 用于“修改已有文件而不是粗暴覆盖”，例如：
  - 在 `src/modules/index.ts` 注册新模块
  - 在路由聚合文件里新增路由
  - 在依赖注入容器或配置中追加 provider
- 推荐用 TS AST 工具（如 ts-morph）实现可靠变更。

**F. 执行与校验（Runner）**
- 在 apply 后执行：
  - `npm test` / `pnpm test`（可选）
  - `npm run lint`、`npm run build`
  - 数据库迁移执行（可选：`ktty-ai db:migrate`）
- 输出报告：成功/失败、如何修复。

---

## 3. 场景1：用户输入“新建项目”

### 流程
1. 用户：`ktty-ai new myapp`
2. CLI 执行：
   - `koatty_cli new myapp --template <preset>`
   - 写入 `.koatty-ai/config.json`（保存默认 DB/ORM/代码风格/模块规范）
   - 可选：安装依赖、初始化 git、首个 commit

### 可配置的“工具模版/preset”
- `preset-minimal`：最小可跑
- `preset-standard`：默认推荐（含 lint/test/日志/统一响应）
- `preset-enterprise`：RBAC、审计日志、OpenAPI、docker、CI

---

## 4. 场景2：用户输入“新增用户管理功能”

### 4.1 交互式需求澄清（建议）
用户一句话通常不够生成“可用且安全”的用户管理，建议 CLI 追问：
- 用户字段：username/email/phone？是否需要状态（启用/禁用）？
- 密码：是否本地登录？需要 hash（bcrypt/argon2）？
- API：是否分页查询？是否支持模糊搜索？
- 权限：谁能创建/删除用户？是否区分 admin？
- DB：已有数据库连接配置？迁移工具用什么？

> 工具把回答写入 Spec，后续可重复执行/迭代。

### 4.2 生成内容（按 Koatty 典型分层）
以一个典型模块为例（实际目录以 Koatty 工程为准）：

**目录结构（示例）**
```
src/
  modules/
    user/
      controller/UserController.ts
      service/UserService.ts
      model/User.ts
      dto/UserDto.ts
      index.ts
  ...
db/
  migrations/
    2026xxxx_create_users.ts
.koatty-ai/
  specs/user-management.yml
```

**生成点**
1. **Model/Entity**
   - 表名、字段类型、唯一索引、默认值、时间戳字段
2. **DTO**
   - CreateUserDto / UpdateUserDto / QueryUserDto
   - 校验规则（必填、长度、邮箱格式等）
3. **Service**
   - `createUser`：处理密码 hash、唯一性检查、事务
   - `listUsers`：分页、排序、过滤
   - `updateUser`：部分更新、敏感字段处理
   - `deleteUser`：软删/硬删可配置
4. **Controller**
   - RESTful endpoints
   - 参数解析与 DTO 校验
   - 统一返回结构（按项目规范）
   - 统一异常（NotFound、BadRequest、Conflict）
5. **数据库迁移**
   - 生成 migration 文件并可执行
   - 或生成 schema 同步脚本（不推荐生产）
6. **注册/装配**
   - 模块导出、路由挂载、容器注入（按 Koatty 范式）
7. **可选增强**
   - OpenAPI 文档注解
   - RBAC/鉴权中间件挂载
   - 测试用例与 mock 数据

---

## 5. “智能化”的关键：两阶段生成（Plan → Apply）

为了避免 LLM 直接写文件导致不可控，建议强制两阶段：

### 5.1 Plan（只输出变更清单）
- `ktty-ai plan "新增用户管理功能"`
- 输出：
  - 将新增哪些文件
  - 将修改哪些文件（用 diff 摘要）
  - 将执行哪些命令（migration、install）
  - 风险提示（比如密码字段需要 hash、需要鉴权等）

### 5.2 Apply（执行落地）
- `ktty-ai apply`
- 执行生成器 + AST patcher
- 运行 format/lint/build/test
- 自动 `git commit -m "feat(user): add user management"`

---

## 6. Koatty 文档对齐策略（RAG + 规则）

### 6.1 检索增强（RAG）
- 根据要生成的组件类型（controller/service/model/dto），从 koatty.org 检索相关页面：
  - 控制器定义与路由方式
  - IOC/依赖注入写法
  - 参数校验与异常处理推荐方式
  - ORM/数据库访问推荐方式
- 将检索结果作为“硬约束上下文”输入生成模型。

### 6.2 规则化约束（避免漂移）
在生成器层面固定：
- 文件命名、目录规范
- 响应结构、错误码规范
- service 不直接依赖 http 上下文、controller 不写业务
- 禁止生成未注册的“自创框架用法”

---

## 7. 技术选型建议

- CLI：Node.js + TypeScript（便于与 Koatty 生态一致）
- 模板引擎：Handlebars/EJS + 代码格式化（prettier）
- AST 修改：ts-morph（可靠插入 import、注册项）
- 文档检索：本地向量库（sqlite + 向量扩展 / chroma / qdrant 均可）
- LLM：可接 OpenAI/国产大模型/本地模型（通过统一 Provider 接口）
- 迁移：根据项目 ORM/DB 选择（若 Koatty 推荐某 ORM，则优先对齐；否则提供 adapter：typeorm/knex/prisma）

---

## 8. 交付形态（你最终能得到什么）

1. `ktty-ai` CLI 工具（可 npm 安装或内网私有包）
2. presets（模板库）+ generators（插件库）
3. `.koatty-ai/specs`：每个功能一份 spec，可审计、可复用、可二次生成
4. 与 Koatty 文档对齐的 RAG 知识库构建脚本（可定期同步 koatty.org）

---

## 9. 建议的下一步（落地路线）

1. **先做 MVP**
   - 支持场景1：new（封装 koatty_cli + preset）
   - 支持场景2：生成 user 模块的 CRUD（controller/service/model/dto + migration）
   - 只支持一种 DB/ORM 组合（减少不确定性）
2. **再做增量能力**
   - AST patch、幂等执行、回滚
   - RBAC、OpenAPI、测试生成
3. **最后做“更智能”**
   - 自动从现有项目推断范式（返回结构、错误处理、日志）
   - 根据现有数据库/模型反向生成 DTO/接口
   - 多轮对话式需求澄清与变更管理

---

如果你愿意，我可以基于你当前 Koatty 项目（或你准备用的 `koatty_cli new` 模板）进一步细化到：
1) 具体的目录结构与注册文件位置（需要你提供初始化后的项目骨架截图/仓库结构），以及  
2) “用户管理”模块的 Spec 模板与生成文件清单（到每个文件的类名、方法名、路由定义）。